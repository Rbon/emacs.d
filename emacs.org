#+TITLE: Rbon's Emacs Config

Hello! You have somehow found my emacs configuration. This file is written in [[https://en.wikipedia.org/wiki/Literate_programming][literate programming style]] using [[https://orgmode.org/][org-mode]]. I'll try not to be more verbose than is necessary.
* Table of Contents                                                     :toc:
- [[#the-axioms-of-this-config][The Axioms of This Config]]
  - [[#emacs-should-be-fun][Emacs should be fun]]
  - [[#emacs-should-be-beautiful][Emacs should be beautiful]]
  - [[#its-worth-it-to-get-wet][It's worth it to get wet]]
  - [[#if-something-goes-horribly-wrong-emacs-should-still-be-usable][If something goes horribly wrong, emacs should still be usable]]
  - [[#escape-should-always-mean-go-up-a-level][Escape should always mean "go up a level"]]
  - [[#it-should-only-take-one-command-to-go-from-a-fresh-install-to-a-full-install][It should only take one command to go from a fresh install to a full install]]
  - [[#the-fewer-packages-the-better][The fewer packages the better]]
  - [[#keybinds-should-be-intuitive][Keybinds should be intuitive]]
  - [[#every-command-should-quack-like-a-duck][Every command should quack like a duck]]
  - [[#shift-should-be-the-only-modifier-key][Shift should be the only modifier key]]
  - [[#keystrokes-are-the-enemy][Keystrokes are the enemy]]
  - [[#if-it-doesnt-fit-on-a-60-keyboard-it-doesnt-belong-in-the-keymap][If it doesn't fit on a 60% keyboard, it doesn't belong in the keymap]]
- [[#keybinds][Keybinds]]
  - [[#miscellaneous][Miscellaneous]]
  - [[#applications][Applications]]
  - [[#files][Files]]
  - [[#frame][Frame]]
  - [[#buffers][Buffers]]
  - [[#eval][Eval]]
  - [[#narrow][Narrow]]
  - [[#selection][Selection]]
  - [[#cursors][Cursors]]
  - [[#help][Help]]
  - [[#window][Window]]
  - [[#quit][Quit]]
  - [[#jump][Jump]]
  - [[#configuration][Configuration]]
  - [[#help-1][Help]]
  - [[#recentf-dialog][Recentf Dialog]]
  - [[#with-editor][With Editor]]
- [[#functions][Functions]]
  - [[#efsdisplay-startup-time][=efs/display-startup-time=]]
  - [[#helm-m-x-read-extended-command][=helm-M-x-read-extended-command=]]
  - [[#rbon-switch-to-scratch][=rbon-switch-to-scratch=]]
  - [[#rbon-center-frame][=rbon-center-frame=]]
  - [[#rbon-define-key][=rbon-define-key=]]
  - [[#buffer-switching][Buffer Switching]]
  - [[#nop][=nop=]]
  - [[#rbon-insert-heading-respect-content][=rbon-insert-heading-respect-content=]]
  - [[#rbon-escape][=rbon-escape=]]
  - [[#rbon-add-cursor-move-down][=rbon-add-cursor-move-down=]]
  - [[#rbon-add-cursor-move-up][=rbon-add-cursor-move-up=]]
  - [[#rbon-evil-mc-make-cursor-in-visual-selection-beg][=rbon-evil-mc-make-cursor-in-visual-selection-beg=]]
  - [[#narrow-and-unfold][=narrow-and-unfold=]]
  - [[#widen-and-fold][=widen-and-fold=]]
  - [[#make-bold][=make-bold=]]
  - [[#make-italic][=make-italic=]]
  - [[#run-code][=run-code=]]
  - [[#my-switch-to-buffer][=my-switch-to-buffer=]]
  - [[#touch-file][=touch-file=]]
  - [[#evil-recentf][=evil-recentf=]]
  - [[#display-startup-echo-area-message][=display-startup-echo-area-message=]]
  - [[#find-init][=find-init=]]
  - [[#find-config-file][=find-config-file=]]
  - [[#load-init][=load-init=]]
  - [[#split-h-and-change-focus][=split-h-and-change-focus=]]
  - [[#rbon-insert-heading-respect-content-1][=rbon-insert-heading-respect-content=]]
  - [[#formatted-copy][=formatted-copy=]]
- [[#misc][Misc]]
  - [[#other][Other]]
  - [[#force-certain-buffers-to-use-the-current-window][Force certain buffers to use the current window]]
- [[#org-mode][Org Mode]]
  - [[#toc-org][=toc-org=]]
  - [[#org-babel][Org-babel]]
  - [[#appearance][Appearance]]
  - [[#keybinds-1][Keybinds]]
  - [[#promoting-and-demoting-subtrees][Promoting and demoting subtrees]]
  - [[#start-folded][Start folded]]
- [[#indent-buffer][Indent Buffer]]
- [[#helm][Helm]]
- [[#text-editing][Text editing]]
  - [[#packages][packages]]
  - [[#line-wrapping][Line wrapping]]
- [[#packages-1][Packages]]
  - [[#straightel][=straight.el=]]
  - [[#use-package][=use-package=]]
  - [[#misc-1][misc]]
- [[#init][Init]]
  - [[#misc-2][Misc]]
  - [[#center-the-frame-on-startup][Center the frame on startup]]
  - [[#garbage-collection-again][garbage collection again]]
- [[#appearance-1][Appearance]]
  - [[#general][General]]
- [[#lsp][LSP]]
- [[#magit][Magit]]
- [[#haskell][Haskell]]
  - [[#config][config]]
  - [[#functions-1][functions]]
  - [[#keybinds-2][keybinds]]
- [[#modeline][Modeline]]
- [[#webkit][Webkit]]
- [[#eradio][Eradio]]
  - [[#options][Options]]
  - [[#keybinds-3][Keybinds]]
- [[#youtube-dl][youtube-dl]]
- [[#japanese-input][Japanese Input]]
- [[#rss-feed-reader][RSS Feed Reader]]
  - [[#package][Package]]
  - [[#global-binds][Global binds]]
  - [[#local-binds][Local binds]]
- [[#youtube-links][youtube links]]
- [[#enqueue-youtube-videos][Enqueue youtube videos]]
  - [[#forward][Forward]]
  - [[#mpvarchive][=mpvarchive=]]
  - [[#mpv-enqueue-maybe-archive][=mpv-enqueue-maybe-archive=]]
  - [[#elfeed-mpv][=elfeed-mpv=]]
  - [[#mpv-search-archive][=mpv-search-archive=]]
  - [[#mpv-build-playlist][=mpv-build-playlist=]]
  - [[#save_playlistlua][=save_playlist.lua=]]
  - [[#mpv-enqueue-play-playlist][=mpv-enqueue-play-playlist=]]
  - [[#mpv-enqueue-play-archive][=mpv-enqueue-play-archive=]]
  - [[#ivy-youtube-dl][=ivy-youtube-dl=]]
- [[#workspaces][Workspaces]]

* The Axioms of This Config
** Emacs should be fun
Every keypress should be intuitive and powerful. Using even the most mundane feature of Emacs should enjoyable.

** Emacs should be beautiful
The way Emacs looks out of the box is shameful. Part of the enjoyment of any software is the aesthetic beauty of it.

** It's worth it to get wet
The interaction between the previous two axioms sometimes results in the unpleasant side-effect of my code not being as as I would normally like it to be.

Throughout this config, you may occasionally find code that seems, at first glance, needlessly [[https://en.wikipedia.org/wiki/Don%27t_repeat_yourself][wet]]. In reality, repetitious code in this config is, most of the time at least, intentional. Let's use an example to walk you through my thought process. Say I have a package, and its related configuration.

#+begin_src emacs-lisp
  (use-package some-package
    :config
    (setq important-var t)
    (setq another-thing nil)
    (setq dont-download "apples"))
#+end_src

Now, say I want to document why I use those variables, and instead of just putting one description for everything above the snippet, I split it into smaller snippets and individually document everything, like so:

"I choose =some-package= because it's great."
#+begin_src emacs-lisp
  (use-package some-package
    :defer t
    :config
#+end_src

"This variable is needed or else =some-package= will not run."
#+begin_src emacs-lisp
  (setq important-var t)
#+end_src

"I'm not sure what this is, but disabling it stopped a crash I was having."
#+begin_src emacs-lisp
  (setq another-thing nil)
#+end_src

"By default, =some-package= downloads a lot of great things, but I have too many apples as it is."
#+begin_src emacs-lisp
  (setq dont-download "apples"))
#+end_src

The previous four snippets will [[https://orgmode.org/manual/Extracting-Source-Code.html][tangle]] out to a file just fine, but what if someone found this config on the internet, but didn't want the last part about apples, and only copied the first three snippets? They would end up with an =End of file during parsing= error. Now, this is an incredibly small example, and even a novice would likely be able to figure out what went wrong and add a closing parenthesis, but if each code snippet were longer, or more complex, or if the depth of nested parens was high, then suddenly the error becomes much more of a headache to debug. And this doesn't just apply to some hypothetical stranger finding these snippets on github. If I myself want to remove or reorder one or more snippets, then I would get errors as well, after tangling them to files.

The solution I have gone for, in this case, is to forgo using a =:config= section entirely, and wrap each snippet in a =with-eval-after-load= expression, which has the same effect of only loading the configuration after the related package is loaded. The final snippets would look like this:

"I choose =some-package= because it's great."
#+begin_src emacs-lisp
  (use-package some-package :defer t)
#+end_src

"This variable is needed or else =some-package= will not run."
#+begin_src emacs-lisp
  (with-eval-after-load 'some-package
    (setq important-var t))
#+end_src

"I'm not sure what this is, but disabling it stopped a crash I was having."
#+begin_src emacs-lisp
  (with-eval-after-load 'some-package
    (setq another-thing nil))
#+end_src

"By default, =some-package= downloads a lot of great things, but I have too many apples as it is."
#+begin_src emacs-lisp
  (with-eval-after-load 'some-package
    (setq dont-download "apples"))
#+end_src

Now each snippet is self-contained and portable. I'm free to move one to an entirely unrelated section of the greater configuration if I want to, and Emacs will happily boot without error. In the end, this results in more lines of code, and that was an especially contrived example, but in the end, I believe the benefits of stability and flexibility outweigh the small cost of writing a few more lines of code. As such, I will employ a similar pattern of "re-wrapping" snippets whenever I can, not just in the case of =use-package=.

** If something goes horribly wrong, emacs should still be usable
** Escape should always mean "go up a level"
** It should only take one command to go from a fresh install to a full install
** The fewer packages the better
** Keybinds should be intuitive
Like it or not, in the decades since Emacs first came around, a standard set of keyboard shortcuts have emerged and are now ubiquitous across almost every operating system. These are:
- =C-c= to copy
- =C-x= to cut
- =C-v= to paste



Ctrl + V (or Shift + Insert)

Paste the selected item.

Ctrl + Z

Undo an action.

** Every command should quack like a duck
the 
** Shift should be the only modifier key
** Keystrokes are the enemy
** If it doesn't fit on a 60% keyboard, it doesn't belong in the keymap

* Global Keybinds
** skeleton
Giving names to the groups of my global leader keybinds. I don't like how this has to be loaded before all other leader binds, and I *especially* don't like how evaling this snippet on its own breaks all leader binds. In the future I would like this  snippet to be portable.
#+begin_src emacs-lisp :tangle ~/.emacs.d/keybinds.el
  (rbon-define-key 'global '(normal visual emacs)
    '("SPC"   ("the final frontier"))
    '("SPC f" ("files"))
    '("SPC F" ("frame"))
    '("SPC b" ("buffers"))
    '("SPC e" ("eval"))
    '("SPC n" ("narrow"))
    '("SPC s" ("selection"))
    '("SPC C" ("cursors"))
    '("SPC h" ("help"))
    '("SPC w" ("window"))
    '("SPC j" ("jump"))
    '("SPC q" ("quit"))
    '("SPC c" ("configuration"))
    '("SPC a" ("applications")))
#+end_src

** Miscellaneous
Escape key stuff
Make it so you only have to hit ESC once to quit menus. Probably has other pleasant side-effects.
#+begin_src emacs-lisp :tangle ~/.emacs.d/keybinds.el
  (define-key key-translation-map (kbd "ESC") (kbd "C-g"))
  (rbon-define-key 'global '(normal visual motion emacs)
    '("<escape>" rbon-escape))
#+end_src

Cursor shortcuts
#+begin_src emacs-lisp :tangle ~/.emacs.d/keybinds.el
  (rbon-define-key 'global 'normal
    '("J" rbon-add-cursor-move-down)
    '("K" rbon-add-cursor-move-up)
    '("N" evil-mc-make-and-goto-next-match)
    '("M" evil-mc-make-all-cursors))
#+end_src

#+begin_src emacs-lisp :tangle ~/.emacs.d/keybinds.el
  (rbon-define-key 'global 'visual
    '("I" evil-mc-make-cursor-in-visual-selection-beg)
    '("A" evil-mc-make-cursor-in-visual-selection-end))


  (rbon-define-key 'global 'insert '("TAB" dabbrev-expand))
                                          ; tab completion in insert mode

  (rbon-define-key 'global '(normal visual emacs)
    '("SPC SPC" ("run a command" . helm-M-x))
    '("SPC DEL" ("go to last location" . pop-global-mark)))

#+end_src

** Applications
#+begin_src emacs-lisp :tangle ~/.emacs.d/keybinds.el
  (rbon-define-key 'global '(normal visual emacs)
    '("SPC a d" dired))
#+end_src

** Files
#+begin_src emacs-lisp :tangle ~/.emacs.d/keybinds.el
  (rbon-define-key 'global '(normal visual emacs)
    '("SPC f f" ("find a file" . helm-find-files))
    '("SPC f s" ("save this file" . save-buffer))
    '("SPC f r" ("recent files" . helm-recentf))
    '("SPC f b" ("open file browser" . magit-dired-jump))
    '("SPC f c" ("open a user config file" . find-config-file)))
#+end_src

** Frame
#+begin_src emacs-lisp :tangle ~/.emacs.d/keybinds.el
  (rbon-define-key 'global '(normal visual emacs)
    '("SPC F c" ("center this frame" . rbon-center-frame))
    '("SPC F m" ("toggle maximized" . toggle-frame-maximized))
    '("SPC F f" ("toggle fullscreen" . toggle-frame-fullscreen)))
#+end_src

** Buffers
#+begin_src emacs-lisp :tangle ~/.emacs.d/keybinds.el
  (rbon-define-key 'global '(normal visual emacs)
    '("SPC b s"   ("save this buffer" . save-buffer))
    '("SPC b c"   ("close this buffer" . kill-this-buffer))
    '("SPC b k"   ("kill this buffer" . kill-this-buffer))
    '("SPC b b"   ("open the buffer list" . helm-buffers-list))
    '("SPC b TAB" ("open last buffer" . my-switch-to-buffer))
    '("SPC b e"   ("eval this buffer" . eval-buffer)))
#+end_src

** Eval
#+begin_src emacs-lisp :tangle ~/.emacs.d/keybinds.el
  (rbon-define-key 'global '(normal visual emacs)
    '("SPC e e" ("eval expression" . eval-expression))
    '("SPC e b" ("eval this buffer" . eval-buffer))
    '("SPC e s" ("eval selection" . eval-region)))
#+end_src

** Narrow
#+begin_src emacs-lisp :tangle ~/.emacs.d/keybinds.el
  (rbon-define-key 'global '(normal visual emacs)
    '("SPC n s" ("narrow to selection" . narrow-to-region))
    '("SPC n w" ("widen" . widen)))
#+end_src

** Selection
#+begin_src emacs-lisp :tangle ~/.emacs.d/keybinds.el
  (rbon-define-key 'global '(normal visual emacs)
    '("SPC s a" ("select everything" . mark-whole-buffer))
    '("SPC s e" ("eval selection" . eval-region))
    '("SPC s i" ("indent selection" . indent-region)))
#+end_src

** Cursors
#+begin_src emacs-lisp :tangle ~/.emacs.d/keybinds.el
  (rbon-define-key 'global '(normal visual emacs)
    '("SPC C a"        ("add all matches" . evil-mc-make-all-cursors))
    '("SPC C <escape>" ("remove all extra cursors" . evil-mc-undo-all-cursors))
    '("SPC C j"        ("add and go down a line" . rbon-add-cursor-next-line))
    '("SPC C u"        ("undo last cursor" . evil-mc-undo-last-added-cursor))
    '("SPC C n"        ("add next match" . evil-mc-make-and-goto-next-match)))
#+end_src

** Help
#+begin_src emacs-lisp :tangle ~/.emacs.d/keybinds.el

  (rbon-define-key 'global '(normal visual emacs)
    '("SPC h h" ("describe something" . helm-apropos))
    '("SPC h l" ("list definitions" . helm-imenu))
    '("SPC h k" ("describe a keybind" . describe-key))
    '("SPC h v" ("describe a keybind" . describe-variable))
    '("SPC h K" ("search keybinds" . helm-descbinds))
    '("SPC h f" ("describe face" . describe-face))
    '("SPC h F" ("describe face" . list-faces-display)))

#+end_src

** Window
#+begin_src emacs-lisp :tangle ~/.emacs.d/keybinds.el
  (rbon-define-key 'global '(normal visual emacs)
    '("SPC w c" ("close this window" . delete-window))
    '("SPC w f" ("fullscreen this window" . delete-other-windows))
    '("SPC w H" ("split this window horizontally" . split-h-and-change-focus))
    '("SPC w V" ("split this window vertically" . split-window-vertically))
    '("SPC w h" ("move window focus left" . windmove-left))
    '("SPC w l" ("move window focus right" . windmove-right))
    '("SPC w k" ("move window focus up" . windmove-up))
    '("SPC w j" ("move window focus down" . windmove-down)))
#+end_src
  
** Quit
#+begin_src emacs-lisp :tangle ~/.emacs.d/keybinds.el
  (rbon-define-key 'global '(normal visual emacs)
    '("SPC q q" ("quit emacs" . save-buffers-kill-terminal)))
#+end_src

** Jump
#+begin_src emacs-lisp :tangle ~/.emacs.d/keybinds.el
  (rbon-define-key 'global '(normal visual emacs)
    '("SPC j d" ("jump to definition" . find-function)))
#+end_src

** Configuration
#+begin_src emacs-lisp :tangle ~/.emacs.d/keybinds.el
  (rbon-define-key 'global '(normal visual emacs)
    '("SPC c a" ("load all configs" . rbon-load-config))
    '("SPC c b" ("bootstrap" . bootstrap))
    '("SPC c c" ("go to config" . rbon-goto-config))
    '("SPC c k" ("go to keybinds" . rbon-goto-keybinds))
    '("SPC c m" ("go to misc config" . rbon-goto-misc))
    '("SPC c f" ("go to functions" . rbon-goto-functions))
    '("SPC c p" ("to go packages" . rbon-goto-packages))
    '("SPC c i" ("to go init" . rbon-goto-init)))
#+end_src

** Help
#+begin_src emacs-lisp :tangle ~/.emacs.d/keybinds.el
  (evil-set-initial-state 'help-mode 'normal)
  (rbon-define-key 'help-mode 'normal '("<escape>" quit-window))
#+end_src

** Recentf Dialog
#+begin_src emacs-lisp :tangle ~/.emacs.d/keybinds.el
  (evil-set-initial-state 'recentf-dialog-mode 'normal)
  (rbon-define-key 'recentf-dialog-mode 'normal
    '("l" widget-button-press)
    '("h" nop)
    '("q" recentf-cancel-dialog))
#+end_src

** With Editor
#+begin_src emacs-lisp :tangle ~/.emacs.d/keybinds.el
  (rbon-define-key 'with-editor-mode 'normal
    '("SPC q f" with-editor-finish)
    '("SPC q c" with-editor-cancel))

#+end_src

* Functions
Be sure to read the docstrings of the functions themselves.
** =efs/display-startup-time=
Stolen from [[https://github.com/daviwil/emacs-from-scratch/blob/master/show-notes/Emacs-Scratch-12.org#lets-find-out-how-long-its-taking][here]].
#+begin_src emacs-lisp :tangle ~/.emacs.d/functions.el
  (defun efs/display-startup-time ()
    (interactive)
    (message "Emacs loaded in %s with %d garbage collections."
             (format "%.2f seconds"
                     (float-time
                      (time-subtract after-init-time before-init-time)))
             gcs-done))

  (add-hook 'emacs-startup-hook #'efs/display-startup-time)
#+end_src

** =rbon-switch-to-scratch=
#+begin_src emacs-lisp :tangle ~/.emacs.d/functions.el
  (defun rbon-switch-to-scratch ()
    "This probably doesn't work right now."
    (interactive)
    (display-buffer-pop-up-frame (get-buffer-create "scratch")))
#+end_src

** =rbon-center-frame=
#+begin_src emacs-lisp :tangle ~/.emacs.d/functions.el
  (defun rbon-center-frame ()
    "Move the current frame to the center of the display.
  Why is this not a built-in function?"
    (interactive)
    (let ((h-offset (/ (- (display-pixel-width) (frame-native-width)) 2))
          (v-offset (/ (- (display-pixel-height) (frame-native-height)) 2)))
      (set-frame-position (selected-frame) h-offset v-offset)))
#+end_src

** =rbon-define-key=
This is probably the one portion of this config that I'm most proud of. In essence, it wraps =evil-define-key= and =add-hook= to create a one-size-fits-all function for defining both global binds, and mode-specific binds, making sure that the latter doesn't pollute the global map.
Currently, there is a limitation that it assumes the associated hook of a mode is just the name of the mode followed by "-hook." This means that if a dev breaks that pattern, this function will silently fail. I might, in the future, add a way to manually add a hook name instead of a mode name, or perhaps I will just make it so that you always use the hook name instead. As it is, it works perfectly for me.
#+begin_src emacs-lisp :tangle ~/.emacs.d/functions.el
  (defun rbon-define-key (mode state &rest bindings)
    "Define one or more key bindings.

  MODE should be a symbol. If it is 'global, then bind keys globally. Otherwise,
  create buffer-local binds when that mode is activated, which means mode-specific
  binds will never leave their designated mode.

  STATE can either be a symbol or list of symbols, just as you would use with
  'evil-define-key'.

  BINDINGS should be in the form of '(KEY DEF), where KEY is a string, and DEF is
  a function.

  KEY is automatically applied to `kbd'.

  Examples:

    (rbon-define-key 'global 'normal '(\"q\" myfun1))

    (rbon-define-key 'some-mode 'insert
      '(\"TAB\" myfun1)
      '(\"SPC b l\" myfun2))

  If `which-key-enable-extended-define-key' is non-nil, then you can optionally
  add a string to replace the function name when using which-key. In which case,
  BINDINGS should take the form of '(KEY (REPLACEMENT . DEF)), where REPLACEMENT
  is a string.

  Examples:

    (rbon-define-key 'another-mode '(normal visual emacs)
      '(\"SPC a\" (\"name of function\" . myfun1)))

    (rbon-define-key 'global 'normal
      '(\"k\" (\"make stuff\" . myfun1))
      '(\"j\" (\"do the thing\" . myfun2)))"
    (declare (indent 2))
    (if (eq mode 'global)
        (mapcar (apply-partially 'rbon--global-set-key state) bindings)
      (add-hook
       (intern (concat (symbol-name mode) "-hook"))
       (apply-partially 'rbon--local-set-key state bindings))))

  (defun rbon--local-set-key (state bindings)
    (dolist (b bindings)
      (evil-define-key state 'local (kbd (nth 0 b)) (nth 1 b))))

  (defun rbon--global-set-key (state binding)
    (let ((key (kbd (nth 0 binding)))
          (def (nth 1 binding)))
      (evil-define-key state 'global key def)))
#+end_src

** Buffer Switching
I'm not sure these even work.
*** =my-change-buffer=
#+begin_src emacs-lisp :tangle ~/.emacs.d/functions.el
  (defun my-change-buffer (change-buffer)
    "Call CHANGE-BUFFER until current buffer is not in `my-skippable-buffers'."
    (let ((initial (current-buffer)))
      (funcall change-buffer)
      (let ((first-change (current-buffer)))
        (catch 'loop
          (while (member (buffer-name) my-skippable-buffers)
            (funcall change-buffer)
            (when (eq (current-buffer) first-change)
              (switch-to-buffer initial)
              (throw 'loop t)))))))
#+end_src

*** =my-next-buffer=
#+begin_src emacs-lisp :tangle ~/.emacs.d/functions.el
  (defun my-next-buffer ()
    "Variant of `next-buffer' that skips `my-skippable-buffers'."
    (interactive)
    (my-change-buffer 'next-buffer))
#+end_src

*** =my-previous-buffer= 
#+begin_src emacs-lisp :tangle ~/.emacs.d/functions.el
  (defun my-previous-buffer ()
    "Variant of `previous-buffer' that skips `my-skippable-buffers'."
    (interactive)
    (my-change-buffer 'previous-buffer))
#+end_src

** =nop=
#+begin_src emacs-lisp :tangle ~/.emacs.d/functions.el
  (defun nop ()
    "Needed to unbind keys. Yes really."
    (interactive))
#+end_src

** =rbon-insert-heading-respect-content=
#+begin_src emacs-lisp :tangle ~/.emacs.d/functions.el
  (defun rbon-insert-heading-respect-content ()
    "Insert a heading and then change to insert state."
    (interactive)
    (org-insert-heading-respect-content)
    (evil-append 0))
#+end_src

** =rbon-escape=
#+begin_src emacs-lisp :tangle ~/.emacs.d/functions.el
  (defun rbon-escape ()
    "Get rid of extra cursors while also normally escaping."
    (interactive)
    (evil-mc-undo-all-cursors)
    (evil-force-normal-state))
#+end_src

** =rbon-add-cursor-move-down=
#+begin_src emacs-lisp :tangle ~/.emacs.d/functions.el
  (defun rbon-add-cursor-move-down ()
    "Add a cursor, and then move down one line."
    (interactive)
    (evil-mc-make-cursor-here) 
    (evil-mc-pause-cursors) 
    (next-line)
    (evil-mc-resume-cursors))
#+end_src

** =rbon-add-cursor-move-up=
#+begin_src emacs-lisp :tangle ~/.emacs.d/functions.el
  (defun rbon-add-cursor-move-up ()
    "Add a cursor, and then move up one line."
    (interactive)
    (evil-mc-make-cursor-here) 
    (evil-mc-pause-cursors) 
    (previous-line)
    (evil-mc-resume-cursors))
#+end_src

** =rbon-evil-mc-make-cursor-in-visual-selection-beg=
#+begin_src emacs-lisp :tangle ~/.emacs.d/functions.el
  (defun rbon-evil-mc-make-cursor-in-visual-selection-beg ()
    (interactive)
    (call-interactively 'evil-mc-make-cursor-in-visual-selection-beg)
    (call-interactively 'evil-force-normal-state)
    (call-interactively 'evil-next-visual-line)
                                          ;(call-interactively 'evil-insert-line))
    )
#+end_src

** =narrow-and-unfold=
#+begin_src emacs-lisp :tangle ~/.emacs.d/functions.el
  (defun narrow-and-unfold ()
    (interactive)
    (evil-open-fold)
    (evil-end-of-line)
    (narrow-to-defun)
    (evil-digit-argument-or-evil-beginning-of-line))
#+end_src

** =widen-and-fold=
#+begin_src emacs-lisp :tangle ~/.emacs.d/functions.el
  (defun widen-and-fold ()
    (interactive)
    (evil-close-folds)
    (widen))
#+end_src

** =make-bold=
#+begin_src emacs-lisp :tangle ~/.emacs.d/functions.el
  (defun make-bold ()
    (interactive)
    (org-emphasize ?*))
#+end_src

** =make-italic=
#+begin_src emacs-lisp :tangle ~/.emacs.d/functions.el
  (defun make-italic ()
    (interactive)
    (org-emphasize ?/))
#+end_src

** =run-code=
#+begin_src emacs-lisp :tangle ~/.emacs.d/functions.el
  (defun run-code ()
    (interactive)
    (haskell-process-load-file)
    (other-window 1)
    (evil-append-line 1))
#+end_src

** =my-switch-to-buffer=
#+begin_src emacs-lisp :tangle ~/.emacs.d/functions.el
  (defun my-switch-to-buffer ()
    "Switch buffers, excluding special buffers."
    (interactive)
    (let ((completion-regexp-list '("\\`[^*]"
                                    "\\`\\([^T]\\|T\\($\\|[^A]\\|A\\($\\|[^G]\\|G\\($\\|[^S]\\|S.\\)\\)\\)\\).*")))
      (switch-to-buffer nil)))
#+end_src

** =touch-file=
#+begin_src emacs-lisp :tangle ~/.emacs.d/functions.el
  (defun touch-file (file)
    "Create a file called FILE.
    If FILE already exists, signal an error."
    (interactive
     (list (read-file-name "Create file: " (dired-current-directory))))
    (let* ((expanded (expand-file-name file))
           (try expanded)
           (dir (directory-file-name (file-name-directory expanded)))
           new)
      (if (file-exists-p expanded)
          (error "Cannot create file %s: file exists" expanded))
      ;; Find the topmost nonexistent parent dir (variable `new')
      (while (and try (not (file-exists-p try)) (not (equal new try)))
        (setq new try
              try (directory-file-name (file-name-directory try))))
      (when (not (file-exists-p dir))
        (make-directory dir t))
      (write-region "" nil expanded t)
      (when new
        (dired-add-file new)
        (dired-move-to-filename))))
#+end_src

** =evil-recentf=
#+begin_src emacs-lisp :tangle ~/.emacs.d/functions.el
  (defun evil-recentf ()
    (interactive)
    (recentf-open-files)
    (evil-normal-state))
#+end_src

** =display-startup-echo-area-message=
#+begin_src emacs-lisp :tangle ~/.emacs.d/functions.el
  (defun display-startup-echo-area-message ()
    "This function replaces the startup minibuffer message with nil."
    (message nil))
#+end_src

** =find-init=
#+begin_src emacs-lisp :tangle ~/.emacs.d/functions.el
  (defun find-init ()
    (interactive)
    (find-file init-path))
#+end_src

** =find-config-file=
#+begin_src emacs-lisp :tangle ~/.emacs.d/functions.el
  (defun find-config-file ()
    (interactive)
    (cd user-emacs-directory)
    (call-interactively 'find-file))
#+end_src

** =load-init=
#+begin_src emacs-lisp :tangle ~/.emacs.d/functions.el
  (defun load-init ()
    (interactive)
    (load-user-file "init.el"))
#+end_src

** =split-h-and-change-focus=
#+begin_src emacs-lisp :tangle ~/.emacs.d/functions.el
  (defun split-h-and-change-focus ()
    (interactive)
    (split-window-horizontally)
    (other-window 1))
#+end_src

** =rbon-insert-heading-respect-content=
#+begin_src emacs-lisp :tangle ~/.emacs.d/functions.el
  (defun rbon-insert-heading-respect-content ()
    "Insert a heading and then change to insert state."
    (interactive)
    (org-insert-heading-respect-content)
    (evil-append 0))
#+end_src

** =formatted-copy=
Shamelessly copied from [[https://kitchingroup.cheme.cmu.edu/blog/2016/06/16/Copy-formatted-org-mode-text-from-Emacs-to-other-applications/][here]].
#+begin_src emacs-lisp :tangle ~/.emacs.d/functions.el
  (defun formatted-copy ()
    "Export region to HTML, and copy it to the clipboard."
    (interactive)
    (save-window-excursion
      (let* ((buf (org-export-to-buffer 'html "*Formatted Copy*" nil nil t t))
             (html (with-current-buffer buf (buffer-string))))
        (with-current-buffer buf
          (shell-command-on-region
           (point-min)
           (point-max)
           "textutil -stdin -format html -convert rtf -stdout | pbcopy"))
        (kill-buffer buf))))
#+end_src

#+begin_src emacs-lisp :tangle ~/.emacs.d/keybinds.el
  (rbon-define-key 'global '(normal visual emacs)
    '("SPC s c" formatted-copy))
#+end_src
   
* Misc
** Other  
This section is pretty messy. I'm slowly trying to organize it.
*** Misc
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/misc.el
  (setq smex-prompt-string "Run command: ")
  (setq confirm-kill-processes nil)
  
  (defcustom my-skippable-buffers '("*Messages*" "*scratch*" "*Help*" "Buffer List*")
    "Buffer names ignored by `my-next-buffer' and `my-previous-buffer'."
    :type '(repeat string))
  
  (global-set-key [remap next-buffer] 'my-next-buffer)
  (global-set-key [remap previous-buffer] 'my-previous-buffer)
  
  (setq org-hide-emphasis-markers t)
  
  (setq default-directory "~/") 
  
  ;; dired stuff
  (setq ls-lisp-use-insert-directory-program nil)
  (require 'ls-lisp)
  
  (setq haskell-process-show-debug-tips nil)
  (setq backup-directory-alist '(("." . "~/.emacs_saves")))
  (ido-mode 1) ; better find-file
  (exec-path-from-shell-initialize) ; fix PATH on macos
  (set-custom-file-path (expand-file-name "custom.el" user-emacs-directory)) ; move custom set variables/faces out of init.el
  (setq init-path (expand-file-name "init.el" user-emacs-directory)) ; assign init.el path to a variable
  (tool-bar-mode -1) ; disable toolbar
  (menu-bar-mode -1) ; disable menubar
  (scroll-bar-mode -1) ; disable scroll bar
  ;; (tab-bar-mode 1) ; enable tab bar (DOESN'T WORK ON MACOS COOL)
  (setq inhibit-splash-screen t) ; disable splash screen
  ;; (which-key-setup-side-window-bottom)
  (setq which-key-idle-secondary-delay 0)
  (when (fboundp 'windmove-default-keybindings) (windmove-default-keybindings)) ; enable windmove
  ;; (add-to-list 'load-path "~/.emacs.d") ; needed for 'require' to see my other configs
  (setq help-window-select t) ; switch to help windows automatically
  (setq initial-scratch-message "") ; make scratch empty
  (setq-default indent-tabs-mode nil) ; use spaces, not tabs
  (setq-default tab-width 2)
  (setq lua-indent-level 2) ; why
  (setq-default evil-shift-width 2) ; whyy
  (blink-cursor-mode 0) ; stop the cursor from blinking
  
  ;; HOOKS
  ;; (add-hook 'emacs-startup-hook 'toggle-frame-fullscreen) ; start emacs in fullscreen
  ;;         (add-hook 'recentf-dialog-mode-hook 'evil-normal-state) ; fix recentf-mode for evil
  ;;         (add-hook 'org-agenda-mode-hook 'evil-normal-state) ; fix org-agenda-mode for evil (DOESN'T WORK?)
  ;;         (add-hook 'haskell-mode-hook 'hasklig-mode) ; use ligatures for Haskell
  ;;         (add-hook 'haskell-mode-hook #'lsp)
  ;;         (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
  ;;         (add-hook 'interactive-haskell-mode-hook 'hasklig-mode) ; use ligatures for Haskell
  ;;         (add-hook 'haskell-literate-mode-hook #'lsp)
  ;;         (add-hook 'error-mode-hook 'evil-emacs-state)
  
  (setq org-agenda-files (list "~/Documents/School/agenda.org"))
  ;; recent file stuff
  (recentf-mode 1)
  (setq recentf-max-menu-items 25)
  (setq recentf-max-saved-items 25)
  
  (add-hook 'haskell-mode-hook 'display-fill-column-indicator-mode)
  (add-hook 'emacs-lisp-mode-hook 'display-fill-column-indicator-mode)
  (setq-default fill-column 80)
  
  ;; teach emacs how to spell
  (setq some-var
        (substring 
         (shell-command-to-string "which ispell")
         0 -1))
  
  ;; enable spell check for text-mode
  (dolist (hook '(text-mode-hook))
    (add-hook hook (lambda () (flyspell-mode 1))))
  
  
  
  
  (autothemer-deftheme
   thing "a test theme"
  
   ((((class color) (min-colors #xFFFFFF)))
  
    (thing-background "gray90"))
  
   ((default (:background "gray90"))))
  
  (provide-theme 'thing)
  
  
  
  
  ;; (setq default-frame-alist
  ;; (append (list '(width . 72) '(height . 40))))
  
                                          ; (set-face-attribute 'mode-line nil
                                          ; :height 10
                                          ; :underline "red"
                                          ; :background "black"
                                          ; :foreground "white"
                                          ; :box nil)
                                          ; 
                                          ; (set-face-attribute 'mode-line-inactive nil
                                          ; :box nil
                                          ; :background "black"
                                          ; :inherit 'mode-line)
  
                                          ; (set-face-attribute 'minibuffer-prompt nil
                                          ; :height 10
                                          ; :underline "red"
                                          ; :background "red"
                                          ; :foreground "blue"
                                          ; :box "red")
  
  (pixel-scroll-mode t)
  
  (defvar booted nil)
  (unless booted (progn 
                                          ; (switch-to-buffer "Untitled")
                                          ; (text-mode) ; needed for spell check
                                          ; (dired ".")
                   (if (file-exists-p (expand-file-name "recentf" user-emacs-directory))
                       (recentf-open-files))
                   (setq booted t))) 
  
#+end_src

** Force certain buffers to use the current window
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/misc.el
  (setq org-src-window-setup 'current-window)
  ;; (add-to-list 'display-buffer-alist
  ;;                  '("*Help*" display-buffer-same-window))
#+end_src

* Org Mode
** Packages
*** [[https://orgmode.org/][org]]
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/org.el
  (use-package org :defer)
#+end_src

*** [[https://github.com/snosov1/toc-org][toc-org]]
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/org.el
  (use-package toc-org
    :after org
    :config
    (toc-org-mode))
#+end_src

** Options
Since we don't want to disable org-confirm-babel-evaluate all of the time, do it around the after-save-hook
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/org.el
  (defun dw/org-babel-tangle-dont-ask ()
    (let ((org-confirm-babel-evaluate nil))
      (org-babel-tangle)))
  (add-hook
   'org-mode-hook
   (lambda () (add-hook
               'after-save-hook #'dw/org-babel-tangle-dont-ask
               'run-at-end 'only-in-org-mode)))
#+end_src

Start folded.
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/org.el
  (setq-default org-startup-folded t)
#+end_src

I don't know what this does.
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/org.el
  (with-eval-after-load 'org
    (setq org-src-fontify-natively t))
#+end_src

#+begin_src emacs-lisp :tangle ~/.emacs.d/config/org.el
  (with-eval-after-load 'org
    (require 'org-tempo)
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
    (add-to-list 'org-structure-template-alist
                 '("ke" . "src emacs-lisp :tangle ~/.emacs.d/keybinds.el"))
    (add-to-list 'org-structure-template-alist
                 '("fu" . "src emacs-lisp :tangle ~/.emacs.d/functions.el"))
    (add-to-list 'org-structure-template-alist
                 '("mi" . "src emacs-lisp :tangle ~/.emacs.d/misc.el"))
    (add-to-list 'org-structure-template-alist
                 '("pa" . "src emacs-lisp :tangle ~/.emacs.d/packages.el"))
    (add-to-list 'org-structure-template-alist
                 '("in" . "src emacs-lisp :tangle ~/.emacs.d/init.el"))
    (add-to-list 'org-structure-template-alist
                 '("ap" . "src emacs-lisp :tangle ~/.emacs.d/appearance.el"))
    (add-to-list 'org-structure-template-alist
                 '("co" . "src emacs-lisp :tangle ~/.emacs.d/config/name.el"))

    )
#+end_src

** Appearance
I like my org mode indented.
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/org.el
  (add-hook 'org-mode-hook 'org-indent-mode)
#+end_src

Enable proportional fonts in =org-mode=.
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/org.el
  (add-hook 'org-mode-hook 'variable-pitch-mode)
#+end_src

Ensure that anything that should be fixed-pitch in Org files appears that way.
I had to compile emacs from source to get =org-block='s background to actually fill the whole line, instead of stopping at the last character. I was previously using a mac port from somewhere that I have forgotten.
Strangely enough, if I eval this expression, then the buggy behavior returns, meaning I have to restart emacs. I will post updates when I eventually roll my own theme.
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/org.el
  (with-eval-after-load 'org
    (custom-theme-set-faces
     'user
     '(org-block ((t (:inherit fixed-pitch :background "#eee8d5"))))
     '(org-block-begin-line ((t (:inherit fixed-pitch :foreground "#93a1a1" :background "#eee8d5"))))
     '(org-block-end-line ((t (:inherit fixed-pitch :foreground "#93a1a1" :background "#eee8d5"))))
     '(org-block-background ((t (:inherit fixed-pitch))))
     '(org-code ((t (:inherit (shadow fixed-pitch)))))
     '(org-document-info ((t (:foreground "dark orange"))))
     '(org-document-info-keyword ((t (:inherit (shadow fixed-pitch)))))
     '(org-indent ((t (:inherit (org-hide fixed-pitch)))))
     '(org-link ((t (:foreground "royal blue" :underline t))))
     '(org-meta-line ((t (:inherit (font-lock-comment-face fixed-pitch)))))
     '(org-property-value ((t (:inherit fixed-pitch))) t)
     '(org-special-keyword ((t (:inherit (font-lock-comment-face fixed-pitch)))))
     '(org-table ((t (:inherit fixed-pitch :foreground "#83a598"))))
     '(org-tag ((t (:inherit (shadow fixed-pitch) :weight bold :height 0.8))))
     '(org-verbatim ((t (:inherit (shadow fixed-pitch)))))))
#+end_src

** Keybinds
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/org.el
    (rbon-define-key 'org-mode '(normal visual emacs)
      '("SPC o"   ("org mode"))
      '("SPC o q" org-edit-special)
      '("SPC o a" ("open the agenda" . org-agenda))
      ;; '("SPC o l" org-babel-execute-src-block)
      '("SPC o a" ("open the agenda" . org-agenda))
      '("SPC n t" ("narrow to subtree" . org-narrow-to-subtree))
      '("SPC s b" ("make bold" . make-bold))
      '("SPC o s" ("scedule a task" . org-schedule))
      '("SPC o d" ("set a deadline" . org-deadline)))
#+end_src

#+begin_src emacs-lisp :tangle ~/.emacs.d/config/org.el
  (rbon-define-key 'org-mode '(normal visual emacs insert)
    '("<S-return>" ("insert a heading" . rbon-insert-heading-respect-content)))
#+end_src

This leaves =evil-ret= unbound, which is fine.
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/org.el
  (rbon-define-key 'org-src-mode 'normal
    '("<escape>" org-edit-src-exit))
#+end_src

#+begin_src emacs-lisp :tangle ~/.emacs.d/config/org.el
  (rbon-define-key 'org-mode 'normal
    '("<return>" org-edit-special))
#+end_src

Org-agenda stuff.
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/org.el
  (rbon-define-key 'org-agenda-mode 'normal
    '("j" org-agenda-next-line)
    '("k" org-agenda-previous-line)
    '("l" org-agenda-later)
    '("h" org-agenda-earlier))
#+end_src

Hydra for promoting and demoting subtrees.
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/org.el
  (defhydra org-move-hydra (:color red)
    ("h" org-promote-subtree "promote subtree")
    ("l" org-demote-subtree  "demote subtree"))

  (rbon-define-key 'org-mode 'normal
    '("SPC o h"
      ("promote subtree" . org-move-hydra/org-promote-subtree))
    '("SPC o l"
      ("demote subtree" . org-move-hydra/org-demote-subtree)))
#+end_src

I don't know why but evil is overriding this for me.
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/org.el
  (rbon-define-key 'org-mode 'normal
    '("<tab>" org-cycle))
#+end_src

Count the words in the current region.
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/text.el
  (rbon-define-key 'org-mode '(normal visual)
    '("SPC r w" ("count words in region" . count-words-region)))
#+end_src

* Indent Buffer
#+begin_src emacs-lisp :tangle ~/.emacs.d/functions.el
  (defun rbon-indent-buffer ()
    (interactive)
    (call-interactively 'mark-whole-buffer)
    (call-interactively 'indent-region))
#+end_src

#+begin_src emacs-lisp :tangle ~/.emacs.d/keybinds.el
  (rbon-define-key 'emacs-lisp-mode 'normal
    '("SPC b i" '("indent buffer" rbon-indent-buffer)))
#+end_src

* Completion
** Packages
*** [[https://github.com/emacs-helm/helm][helm]]
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/helm.el
  (use-package helm :config (helm-mode 1))
#+end_src

*** [[https://github.com/emacs-helm/helm-descbinds][helm-descbinds]]
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/helm.el
  (use-package helm-descbinds
    :after helm
    :config (helm-descbinds-mode))
#+end_src

** Options
Enable this to do stuff like =helm-imenu=.
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/helm.el
  (with-eval-after-load 'helm
    (semantic-mode 1))
#+end_src

I don't know what this does.
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/helm.el
  (with-eval-after-load 'helm
    (require 'helm-config))
#+end_src

Set a custom =M-x= prompt. Be default, =helm= doesn't let you do this, so I had to modify =helm-M-x-read-extended-command=.
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/helm.el
  (with-eval-after-load 'helm
    (setq helm-M-x-prompt-string "Command: "))
#+end_src

** Keybinds
*** Local Keybinds
Evil navigation of Helm buffers. Taken from [[https://github.com/abo-abo/hydra/wiki/Helm][here]].
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/helm.el
  (with-eval-after-load 'helm
    (defhydra helm-like-unite (:hint nil
                                     :color pink)
      "
  Nav ^^^^^^^^^        Mark ^^          Other ^^       Quit
  ^^^^^^^^^^------------^^----------------^^----------------------
  _K_ ^ ^ _k_ ^ ^     _m_ark           _v_iew         _i_: cancel
  ^↕^ _h_ ^✜^ _l_     _t_oggle mark    _H_elp         _o_: quit
  _J_ ^ ^ _j_ ^ ^     _U_nmark all     _d_elete
  ^^^^^^^^^^                           _f_ollow: %(helm-attr 'follow)
  "
      ;; arrows
      ("h" helm-beginning-of-buffer)
      ("j" helm-next-line)
      ("k" helm-previous-line)
      ("l" helm-end-of-buffer)
      ;; beginning/end
      ("g" helm-beginning-of-buffer)
      ("G" helm-end-of-buffer)
      ;; scroll
      ("K" helm-scroll-other-window-down)
      ("J" helm-scroll-other-window)
      ;; mark
      ("m" helm-toggle-visible-mark)
      ("t" helm-toggle-all-marks)
      ("U" helm-unmark-all)
      ;; exit
      ("<escape>" keyboard-escape-quit "" :exit t)
      ("o" keyboard-escape-quit :exit t)
      ("i" nil)
      ;; sources
      ("}" helm-next-source)
      ("{" helm-previous-source)
      ;; rest
      ("H" helm-help)
      ("v" helm-execute-persistent-action)
      ("d" helm-persistent-delete-marked)
      ("f" helm-follow-mode))

    (define-key helm-map (kbd "<escape>") 'helm-like-unite/body)
    (define-key helm-map (kbd "C-k") 'helm-like-unite/body)
    (define-key helm-map (kbd "C-o") 'helm-like-unite/body))
#+end_src

*** Global Keybinds
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/helm.el
  (rbon-define-key 'global 'normal
    '("SPC /" helm-occur))
#+end_src

** Functions
*** =helm-M-x-read-extended-command= 
By default, =helm-M-x-read-extended-command= doesn't let you change the prompt. It's just hardcoded into the function. So I blatantly copy/pasted it here, with one whole line changed to allow the prompt to be a user variable. Maybe one day when I know how, I'll submit a pull request.

It probably has something to do with the way packages are ordered, but this needs to be wrapped in an =with-eval-after-load= in order to be properly loaded.
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/helm.el
  (with-eval-after-load 'helm-command
    (defun helm-M-x-read-extended-command (collection &optional predicate history)
      "Read or execute action on command name in COLLECTION or HISTORY.
  
  This function has been copied verbatim from its original location and now lives
  in `~/.emacs.d/config/helm.el', with one line changed to allow user to change the
  prompt from \"M-x\" to something else.
  Customize `helm-M-x-prompt-string' to change the prompt.
  
  When `helm-M-x-use-completion-styles' is used, Emacs
  `completion-styles' mechanism is used, otherwise standard helm
  completion and helm fuzzy matching are used together.
  
  Helm completion is not provided when executing or defining kbd
  macros.
  
  Arg COLLECTION should be an `obarray' but can be any object
  suitable for `try-completion'.  Arg PREDICATE is a function that
  default to `commandp' see also `try-completion'.  Arg HISTORY
  default to `extended-command-history'."
      (let* ((helm--mode-line-display-prefarg t)
             (pred (or predicate #'commandp))
             (helm-fuzzy-sort-fn (lambda (candidates _source)
                                   ;; Sort on real candidate otherwise
                                   ;; "symbol (<binding>)" is used when sorting.
                                   (helm-fuzzy-matching-default-sort-fn-1 candidates t)))
             (sources `(,(helm-make-source "Emacs Commands history" 'helm-M-x-class
                           :data (lambda ()
                                   (helm-comp-read-get-candidates
                                    ;; History should be quoted to
                                    ;; force `helm-comp-read-get-candidates'
                                    ;; to use predicate against
                                    ;; symbol and not string.
                                    (or history 'extended-command-history)
                                    ;; Ensure using empty string to
                                    ;; not defeat helm matching fns [1]
                                    pred nil nil ""))
                           :fuzzy-match helm-M-x-fuzzy-match)
                        ,(helm-make-source "Emacs Commands" 'helm-M-x-class
                           :data (lambda ()
                                   (helm-comp-read-get-candidates
                                    ;; [1] Same comment as above.
                                    collection pred nil nil ""))
                           :fuzzy-match helm-M-x-fuzzy-match)))
             (prompt (concat (cond
                              ((eq helm-M-x-prefix-argument '-) "- ")
                              ((and (consp helm-M-x-prefix-argument)
                                    (eq (car helm-M-x-prefix-argument) 4)) "C-u ")
                              ((and (consp helm-M-x-prefix-argument)
                                    (integerp (car helm-M-x-prefix-argument)))
                               (format "%d " (car helm-M-x-prefix-argument)))
                              ((integerp helm-M-x-prefix-argument)
                               (format "%d " helm-M-x-prefix-argument)))
                             helm-M-x-prompt-string))) ; this is the line I modified
        (setq helm-M-x--timer (run-at-time 1 0.1 'helm-M-x--notify-prefix-arg))
        ;; Fix Bug#2250, add `helm-move-selection-after-hook' which
        ;; reset prefix arg to nil only for this helm session.
        (add-hook 'helm-move-selection-after-hook
                  'helm-M-x--move-selection-after-hook)
        (add-hook 'helm-before-action-hook
                  'helm-M-x--before-action-hook)
        (when (and sources helm-M-x-reverse-history)
          (setq sources (nreverse sources)))
        (unwind-protect
            (progn
              (setq current-prefix-arg nil)
              (helm :sources sources
                    :prompt prompt
                    :buffer "*helm M-x*"
                    :history 'helm-M-x-input-history))
          (helm-M-x--unwind-forms)))))
#+end_src

* Text editing
** Packages
*** [[https://github.com/emacs-evil/evil][evil]]
Emacs is a pretty good operating system, but it's just missing a good text editor.
#+begin_src emacs-lisp :tangle ~/.emacs.d/packages.el
  (use-package evil :demand
    :config (evil-mode 1))
#+end_src

*** [[https://github.com/emacsorphanage/evil-textobj-line][evil-textobj-line]]
#+begin_src emacs-lisp :tangle ~/.emacs.d/packages.el
  (use-package evil-textobj-line :demand :after evil)
#+end_src

*** [[https://github.com/gabesoft/evil-mc][evil-mc]]
Multiple cursors.
#+begin_src emacs-lisp :tangle ~/.emacs.d/packages.el
  (use-package evil-mc :demand :after evil
    :config (global-evil-mc-mode 1))
#+end_src

*** [[https://github.com/emacs-evil/evil-surround][evil-surround]]
Surround text with stuff.
#+begin_src emacs-lisp :tangle ~/.emacs.d/packages.el
  (use-package evil-surround :demand :after evil
    :config (global-evil-surround-mode 1))
#+end_src

*** [[https://elpa.gnu.org/packages/undo-tree.html][undo-tree]]
I don't like this package, but I'm too lazy to change it.
#+begin_src emacs-lisp :tangle ~/.emacs.d/packages.el
  (use-package undo-tree :after evil
    :config
    (global-undo-tree-mode 1)
    (setq evil-undo-system 'undo-tree))
#+end_src

*** [[https://github.com/flycheck/flycheck][flycheck]]
Spellchecking.
#+begin_src emacs-lisp :tangle ~/.emacs.d/packages.el
  (use-package flycheck)
#+end_src

*** [[https://github.com/justbur/emacs-which-key][which-key]]
=which-key= is possibly my favorite package.

Set this to =t= to enable keybinds with custom names, using this syntax: ='("foo" . long-command-name-foo)=. The instructions say to set this before loading the package.
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/text.el
  (setq which-key-enable-extended-define-key t)
#+end_src

Enable the package itself.
#+begin_src emacs-lisp :tangle ~/.emacs.d/packages.el
  (use-package which-key :demand :config (which-key-mode))
#+end_src

** Options
Wrap text in all buffers by default.
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/text.el
  (global-visual-line-mode 1)
#+end_src

Making moving up and down lines behave like a modern text editor.
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/text.el
  (with-eval-after-load 'evil
    (define-key evil-normal-state-map "j" 'evil-next-visual-line)
    (define-key evil-normal-state-map "k" 'evil-previous-visual-line))
#+end_src

* Package Management
** =straight.el=
This makes each use-package form also invoke straight.el to install the package, unless otherwise specified.
#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (setq straight-use-package-by-default t)
#+end_src

I won't pretend to understand what everything here does.
#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+end_src

** =use-package=
#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (straight-use-package 'use-package)
  (setq use-package-verbose t)
  (setq use-package-always-defer t)
#+end_src

** misc
#+begin_src emacs-lisp :tangle ~/.emacs.d/packages.el



  ;; smooth-scrolling-mode

  (use-package markdown-mode)

  (use-package lua-mode
    :mode "\\.lua\\'"
    :interpreter "lua")

  (use-package solarized-theme
    :defer t)

  (use-package exec-path-from-shell) ; fix path on macos
                                          ; (use-package smex) ; better than M-x


                                          ; (use-package autothemer)
                                          ; (use-package doom-themes)
                                          ; (use-package spacegray-theme)

  (use-package hydra
    :defer t)


  (defun set-custom-file-path (path)
    (unless (file-exists-p path)
      (write-region "" nil path))
    (setq custom-file path)
    (load custom-file))
#+end_src

* Init
** Misc
The default is 800 kilobytes.  Measured in bytes.
#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (setq gc-cons-threshold (* 100 1000 1000))
#+end_src

#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (defun my/load-softly (filename)
    "As `require', but instead of an error just print a message.

  If there is an error, its message will be included in the message
  printed.

  Like `require', the return value will be FEATURE if the load was
  successful (or unnecessary) and nil if not."
    (condition-case err
        (load filename) 
      (error (message "Error loading %s: \"%s\""
                      (if filename (format "%s (%s)" "TEST" filename) "TEST")
                      (error-message-string err))
             nil)))

  (defun load-user-file (filename)
    "Load a file in current user's configuration directory"
    (interactive "f")
    (unless (file-exists-p
             (expand-file-name filename user-emacs-directory))
      (write-region "" nil filename))
    (load-file (expand-file-name filename user-emacs-directory)))  

  (defun bootstrap ()
    "Sync and load user configs."
    (interactive)
    (load-user-file "packages.el")
    ;; (sync-all-packages)
    (load-user-file "functions.el")
    (load-user-file "appearance.el")
    (load-user-file "misc.el")
    (load-user-file "keybinds.el"))

  (bootstrap)
  (put 'narrow-to-region 'disabled nil)

  ;; (defun goto-config ()
  ;; "Open emacs.org."
  ;; (interactive)
  ;; (find-file "~/.emacs.d/emacs.org")
  ;; (widen)
  ;; (evil-goto-first-line)
  ;; (evil-close-folds))
#+end_src

** Center the frame on startup
This is called last to ensure frame is properly centered. If I could figure out a way to keep this out of ~init.el~ it would not be here, but this needs to be called after everything else otherwise it doesn't work.
#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  (defun rbon-center-frame ()
    "Move the current frame to the center of the display.
  Why is this not a built-in function?"
    (interactive)
    (let ((h-offset (/ (- (display-pixel-width) (frame-native-width)) 2))
          (v-offset (/ (- (display-pixel-height) (frame-native-height)) 2)))
      (set-frame-position (selected-frame) h-offset v-offset)))
  (eval-after-load "~/.dshdusdhsudh"
    (when window-system (rbon-center-frame)))
#+end_src

** garbage collection again
Dial the GC threshold back down so that garbage collection happens more frequently but in less time.
#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  ;; Make gc pauses faster by decreasing the threshold.
  (setq gc-cons-threshold (* 2 1000 1000))
#+end_src

** config files   
Load every elisp file in =~/.emacs.d/config=.
#+begin_src emacs-lisp :tangle ~/.emacs.d/init.el
  ;; (mapc 'load (file-expand-wildcards "~/.emacs.d/config/*.el"))
  (mapc 'my/load-softly (file-expand-wildcards "~/.emacs.d/config/*.el"))
#+end_src

* Appearance
** General
Best theme fight me.
#+begin_src emacs-lisp :tangle ~/.emacs.d/appearance.el
  (load-theme 'solarized-light t) ; 
#+end_src

#+begin_src emacs-lisp :tangle ~/.emacs.d/appearance.el
  (set-face-attribute 'default nil
                      :family "Hasklig"
                      :height 150
                      :weight 'normal
                      :width 'normal)
#+end_src

** Modeline
In terms of modeline, we have no modeline. No but in all seriousness. I use the package =mini-modeline= to put the modeline in the minibuffer.

*** Packages
*** [[https://github.com/kiennq/emacs-mini-modeline][mini-modeline]]
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/mini-modeline.el
  (use-package mini-modeline :demand)
#+end_src

*** Options
This is super messy and I don't really know everything that's going on. I just kinda poked at this until things looked right. Future me should definitely clean this up.
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/mini-modeline.el
  (with-eval-after-load 'mini-modeline
    (setq-default mode-line-format nil) 
    (setq mode-line-format nil) 
    ;; (setq-default mode-line-format "") ; get rid of status line
    ;;   (setq mode-line-format nil) 
    (setq-default mini-modeline-enhance-visual nil) ; does the opposite of what I would think
    (setq-default mini-modeline-display-gui-line t)
    (setq-default window-divider-default-places t) 
    (setq-default window-divider-default-bottom-width 1) 
    (setq-default window-divider-default-right-width 1)
    (setq mode-line-format nil) 
    (mini-modeline-mode t)
    (window-divider-mode t)
    (setq mode-line-format nil) 

    (setq-default mini-modeline-r-format
                  (list
                   '("%e"
                     mode-line-buffer-identification
                     mode-line-modified)))

    ;;     (setq-default mini-modeline-r-format
    ;;                   (list
    ;;                    '("%e"
    ;;                      mode-line-buffer-identification
    ;;                      mode-line-modified) " "
    ;;                    '(:eval (eyebrowse-mode-line-indicator))))

    (setq-default mode-line-format nil) 
    )
#+end_src

* LSP
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/lsp.el
  (use-package lsp-mode
    :after haskell-mode
    :config
    (rbon-define-key 'lsp-mode 'normal
      '("SPC b f" ("format this buffer" . lsp-format-buffer))
      '("SPC s f" ("format selection" . lsp-format-region))
      '("SPC h h" ("describe something" . lsp-describe-thing-at-point))
      '("SPC j d" ("jump to definition" . lsp-find-definition)))
    )
  (use-package lsp-haskell
    :after haskell-mode)
#+end_src

* Version control
** Packages
*** [[https://magit.vc/][magit]]
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/magit.el
  (use-package magit :commands magit)
#+end_src

** Keybinds
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/magit.el
  (rbon-define-key 'global '(normal visual emacs)
    '("SPC a m" magit))
#+end_src

#+begin_src emacs-lisp :tangle ~/.emacs.d/config/magit.el
  (rbon-define-key 'magit-mode 'emacs
    '("J"        magit-status-jump)
    '("j"        magit-next-line)
    '("k"        magit-previous-line)
    '("H"        magit-discard)
    '("<escape>" magit-mode-bury-buffer))
#+end_src

* Haskell
By default, the haskell interactive prompt doesn't play well with evil mode. The following functions have all been sandwiched between some evil bread to make them work with the concept of the =normal= state.
** Options
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/haskell.el
  (use-package haskell-mode
    :mode "\\.hs\\'"
    :interpreter "haskell")

  (use-package hasklig-mode
    :after haskell-mode)

#+end_src

** Functions
*** =rbon-haskell-interactive-mode-kill-whole-line=
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/haskell.el
  (defun rbon-haskell-interactive-mode-kill-whole-line ()
    "Wraps `haskell-interactive-mode-kill-whole-line' to work with evil."
    (interactive)
    (call-interactively 'evil-append-line)
    (call-interactively 'haskell-interactive-mode-kill-whole-line)
    (evil-normal-state))
#+end_src

*** =rbon-haskell-interactive-mode-history-previous=
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/haskell.el
  (defun rbon-haskell-interactive-mode-history-previous ()
    "Wraps `haskell-interactive-mode-history-previous' to work with evil."
    (interactive)
    (call-interactively 'evil-append-line)
    (call-interactively 'haskell-interactive-mode-history-previous)
    (evil-normal-state))
#+end_src

*** =rbon-haskell-interactive-mode-history-next=
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/haskell.el
  (defun rbon-haskell-interactive-mode-history-next ()
    "Wraps `haskell-interactive-mode-history-next' to work with evil."
    (interactive)
    (call-interactively 'evil-append-line)
    (call-interactively 'haskell-interactive-mode-history-next)
    (evil-normal-state))
#+end_src

*** =rbon-insert-haskell-prompt-start=
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/haskell.el
  (defun rbon-insert-haskell-prompt-start ()
    "Enter the insert state at the start of the haskell prompt."
    (interactive)
    (goto-char haskell-interactive-mode-prompt-start)
    (call-interactively 'evil-insert))
#+end_src
   
*** =rbon-goto-haskell-prompt-start=
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/haskell.el
  (defun rbon-goto-haskell-prompt-start ()
    "Go to the start of the haskell prompt."
    (interactive)
    (goto-char haskell-interactive-mode-prompt-start))
#+end_src

** Keybinds
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/haskell.el
  (rbon-define-key 'haskell-mode 'normal
    '("SPC b e" ("eval this buffer" . run-code)))

  (rbon-define-key 'haskell-interactive-mode 'insert
    '("TAB" haskell-interactive-mode-tab)
    '("SPC" haskell-interactive-mode-space))

  (rbon-define-key 'haskell-interactive-mode 'normal
    '("J" rbon-haskell-interactive-mode-history-next)
    '("K" rbon-haskell-interactive-mode-history-previous)
    '("I" rbon-insert-haskell-prompt-start)
    '("^" rbon-goto-haskell-prompt-start)
    '("<S-backspace>" rbon-haskell-interactive-mode-kill-whole-line)
    '("RET" haskell-interactive-mode-return))

  (rbon-define-key 'haskell-error-mode 'normal '("q" quit-window))
#+end_src

* Webkit
** Keybinds
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/webkit.el
  (rbon-define-key 'xwidget-webkit-mode '(normal)
    '("DEL"   xwidget-webkit-back))
#+end_src

* Internet radio
** Package
*** [[https://github.com/fossegrim/eradio][eradio]]
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/eradio.el
  (use-package eradio :commands eradio)
#+end_src

** Options
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/eradio.el
  (with-eval-after-load 'eradio
    (setq eradio-player
          '("/Applications/mpv.app/Contents/MacOS/mpv"
            "--no-video"
            "--no-terminal")))
#+end_src

#+begin_src emacs-lisp :tangle ~/.emacs.d/config/eradio.el
  (with-eval-after-load 'eradio
    (setq eradio-channels
          '(
            ;; electronica with defcon-speaker bumpers
            ("def con - soma fm"
             . "https://somafm.com/defcon256.pls")

            ;; \m/
            ("metal - soma fm"
             . "https://somafm.com/metal130.pls")

            ;; cyberpunk-esque electronica
            ("cyberia - lainon"
             . "https://lainon.life/radio/cyberia.ogg.m3u")

            ;; boring ambient, but with lain
            ("cafe - lainon"
             . "https://lainon.life/radio/cafe.ogg.m3u")    

            ("groove salad - soma fm"
             . "https://somafm.com/groovesalad.pls"))))
#+end_src

** Keybinds
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/eradio.el
  (rbon-define-key 'global '(normal visual emacs)
    '("SPC r"  ("radio"))
    '("SPC r p" ("play" . eradio-play))
    '("SPC r s" ("stop" . eradio-stop))
    '("SPC r t" ("toggle" . eradio-toggle)))
#+end_src

* youtube-dl
#+begin_src emacs-lisp :tangle ~/.emacs.d/keybinds.el
  ;;  (rbon-define-key 'dired-mode 'normal
  ;;    '("h" dired-up-directory)
  ;;    '("j" dired-next-line)
  ;;    '("k" dired-previous-line)
  ;;    '("l" dired-find-file)
  ;;    '("/" evil-search-forward)
  ;;    '("t" touch-file))

  ;; (add-hook 'dired-mode-hook 'dired-hydra/body)

  (setq youtube-dl-command "youtube-dl --simulate")

  (defun youtube-dl-test ()
    (interactive)
    (insert (shell-command-to-string "uptime"))
    )




  ;; (defvar youtube-dl-mode-map nil "Keymap for `youtube-dl-mode'")
  ;; ;; make sure that the var name is your mode name followed by -map. That way, define-derived-mode will automatically set it as local map
  ;; 
  ;; ;; also, by convention, variable names for keymap should end in -map
  ;; 
  ;; (progn
  ;;   (setq youtube-dl-mode (make-sparse-keymap))
  ;; 
  ;;   (define-key youtube-dl-mode-map (kbd "d") 'youtube-dl-test)
  ;; 
  ;; 
  ;;   ;; by convention, major mode's keys should begin with the form C-c C-‹key›
  ;;   ;; by convention, keys of the form C-c ‹letter› are reserved for user. don't define such keys in your major mode
  ;;   )
  ;; 
  ;; ;; ----------------------------------------
  ;; ;; define the mode
  ;; 
  ;; (define-derived-mode my-mode prog-mode "my"
  ;;   "my-mode is a major mode for editing language my.
  ;; 
  ;; \\{my-mode-map}"
  ;; 
  ;;   ;; actually no need
  ;;   (use-local-map my-mode-map) ; if your keymap name is modename follow by -map, then this line is not necessary, because define-derived-mode will find it and set it for you
  ;; 
  ;;   )
  ;; 
  ;;      (define-derived-mode youtube-dl-mode fundamental-mode "youtube-dl"
  ;;        "work in progress"
  ;; 
  ;;        )

#+end_src
   
* Japanese Input
#+begin_src emacs-lisp :tangle ~/.emacs.d/keybinds.el
  (rbon-define-key 'global '(normal visual emacs)
    '("SPC i"  ("input method"))
    '("SPC i t" ("toggle input method" . toggle-input-method)))
#+end_src

* RSS Feed Reader
** Packages
*** [[https://github.com/skeeto/elfeed][elfeed]]
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/elfeed.el
  (use-package elfeed)
#+end_src

*** [[https://github.com/Manoj321/elfeed-dashboard][elfeed-dashboard]]
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/elfeed.el
  ;; (use-package elfeed-dashboard
  ;;   :demand
  ;;   :ensure t
  ;;   :config
  ;;   (setq elfeed-dashboard-file "~/elfeed-dashboard.org")
  ;;   ;; update feed counts on elfeed-quit
  ;;   (advice-add 'elfeed-search-quit-window :after #'elfeed-dashboard-update-links))
#+end_src

** Options
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/elfeed.el
  (defvar rbon-elfeed-timeframe "@1-month-ago")
  (defvar rbon-elfeed-unread "+unread")
  (defvar rbon-elfeed-tags "")
#+end_src

** Global binds
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/elfeed.el
  (rbon-define-key 'global '(normal visual emacs)
    '("SPC a e" elfeed))
#+end_src

** Local binds
Binds for the main feed list buffer.
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/elfeed.el
  (with-eval-after-load 'elfeed
    (rbon-define-key 'elfeed-search-mode '(normal)
      '("g" elfeed-search-update--force)
      '("G" elfeed-search-fetch)
      '("s" elfeed-search-live-filter)
      '("c" elfeed-search-clear-filter)
      '("<return>" elfeed-search-show-entry)
      '("b" elfeed-search-browse-url)
      '("y" elfeed-search-yank)
      '("r" elfeed-search-untag-all-unread)
      '("u" elfeed-search-tag-all-unread)
      '("+" elfeed-search-tag-all)
      '("-" elfeed-search-untag-all)
      '("m" elfeed-mpv)
      '("j" evil-next-line)
      '("k" evil-previous-line)
      '("f u" ("unread" . rbon-elfeed-set-unread-true))
      '("f a" ("all" . rbon-elfeed-set-unread-false))
      '("f v" ("vtuber" . rbon-elfeed-set-tags-vtuber))
      '("f V" ("not vtuber" . rbon-elfeed-set-tags-no-vtuber))
      '("f w" ("week" . rbon-elfeed-set-timeframe-one-week))
      '("f m" ("month" . rbon-elfeed-set-timeframe-one-month))
      '("<escape>" kill-this-buffer)))
#+end_src

Binds specifically for the buffer that shows the full info for specific entries.
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/elfeed.el
  (with-eval-after-load 'elfeed
    (message "loaded some keybinds")
    (rbon-define-key 'elfeed-show-mode '(normal)
      '("m" elfeed-mpv)
      '("<escape>" kill-this-buffer)))
#+end_src

** Functions
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/elfeed.el
  (defun rbon-elfeed-search-update ()
    ;;    (setq elfeed-search-filter
    ;;          (mapconcat 'identity '(rbon-elfeed-timeframe
    ;;                                rbon-elfeed-unread
    ;;                                rbon-elfeed-tags) " ")))
      (setq elfeed-search-filter (concat
                                  rbon-elfeed-timeframe
                                  " "
                                  rbon-elfeed-unread
                                  " "
                                  rbon-elfeed-tags))
     (elfeed-search-update--force))

    (defun rbon-elfeed-set-timeframe-one-week ()
      (interactive)
      (setq rbon-elfeed-timeframe "@1-week-ago")
      (rbon-elfeed-search-update))

    (defun rbon-elfeed-set-timeframe-one-month ()
      (interactive)
      (setq rbon-elfeed-timeframe "@1-month-ago")
      (rbon-elfeed-search-update))

    (defun rbon-elfeed-set-unread-true ()
      (interactive)
      (setq rbon-elfeed-unread "+unread")
      (rbon-elfeed-search-update))

    (defun rbon-elfeed-set-unread-false ()
      (interactive)
      (setq rbon-elfeed-unread "")
      (rbon-elfeed-search-update))

    (defun rbon-elfeed-set-tags-vtuber ()
      (interactive)
      (setq rbon-elfeed-tags "+vtuber")
      (rbon-elfeed-search-update))

    (defun rbon-elfeed-set-tags-no-vtuber ()
      (interactive)
      (setq rbon-elfeed-tags "-vtuber")
      (rbon-elfeed-search-update))
#+end_src

* youtube links
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/youtube.el
  (defun mpv-play-url (url &rest args)
    ""
    (interactive)
                                          ; (start-process "mpv" "*mpv*" "mpv" url))
    (shell-command (concat "open -a mpv \"" url "\"")))

                                          ;   (setq browse-url-browser-function
                                          ;     (quote
                                          ;       (("youtu\\.?be" . mpv-play-url)
                                          ;       ("." . eww-browse-url))))
#+end_src

* Enqueue youtube videos
The following is taken from [[https://www.reddit.com/r/emacs/comments/efsg0t/how_i_enqueue_online_videos_in_mpv_with_emacs/][here]], formatted to better fit this config.

** Forward
*How I enqueue online videos in mpv with Emacs*
I was a bit hesitant about sharing this setup which I have created for mpv, but I don't know of any other solution that fulfils all my needs so I thought maybe someone else will find it useful too. You basically just need gnu+linux, emacs, mpv, youtube-dl and optionally qutebrowser to use them. You can download youtube-dl with pip (pip3 install --user youtube-dl) and qutebrowser's instructions are here: http://qutebrowser.org/doc/install.html

When playing local videos files with mpv through emacs I simply use the package "openwith" which is great for opening files from dired, ivy, find-find, directly with external applications based on file extensions. https://github.com/emacsmirror/openwith

But that package is not suitable for streaming online videos. Also I usually find myself wanting to play a number of videos from my browser one after the other without opening a new instance of mpv for every video. I wrote these functions because it's much better to play videos in mpv instead of any browser. The qutebrowser integration needs emacsclient but I guess it should be easy to simply change emacsclient to emacs in those settings and they'll work without the client.

These functions will enqueue your online videos in mpv and also keep an archive in plaintext with all the titles and links. The archive is useful for searching old videos you have seen and then directly playing them with mpv, or opening them with your browser. And there's an option of turning off the archive when you don't need it.

These functions will also allow you to create and play plaintext m3u playlists of videos.

I use these functions everyday and have integrated them with my browser (qutebrowser) and rss reader (elfeed). So here we go!

** =mpvarchive=
First define a variable for where you like to keep your archive file. You can change this location here if you want:
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/youtube.el
  (defvar mpvarchive "~/.cache/mpvarchive"
    "file to use as archive for \\[mpv-enqueue-maybe-archive]")
#+end_src

** =mpv-enqueue-maybe-archive=
Now, here's the main function. It creates with mkfifo a named pipe in the /tmp/ folder (if the pipe doesn't already exist) and sends to it new videos as links if mpv is already playing, otherwise if it's the first video then it runs mpv directly. By default it also triggers the archive function which saves your link, its title and its duration, which you can later search from a handy function.
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/youtube.el
  (defun mpv-enqueue-maybe-archive (&optional link noarchive)
    (interactive)
    (unless link (setq link (current-kill 0)))
    (let ((mpvfifo "/tmp/mpvfifo"))
      (unless (and (file-exists-p mpvfifo)(not (file-regular-p mpvfifo)))
        (call-process "mkfifo" nil nil nil mpvfifo))
      (if (eq (process-status "mpv-enqueue") 'run)
          (let ((inhibit-message t))
            (write-region (concat "loadfile \"" link "\" append-play" "\n") nil mpvfifo))
        (make-process :name "mpv-enqueue"
                      :connection-type 'pty
                      :command (list
                                "mpv"
                                (concat "--input-file=" mpvfifo)
                                "--player-operation-mode=pseudo-gui" link)
                      :sentinel (lambda (p e)(message "Process %s %s" p (replace-regexp-in-string "\n\\'" "" e))))))
    (unless noarchive
      (let ((buffer (generate-new-buffer "*mpv-archive*")))
        (make-process :name "mpv-archive"
                      :connection-type 'pipe
                      :buffer buffer
                      :command (list "youtube-dl" "--ignore-config" "--get-title" "--get-duration" link)
                      :sentinel `(lambda (p e)
                                   (message "Process %s %s" p (replace-regexp-in-string "\n\\'" "" e))
                                   (set-buffer ',buffer)
                                   (goto-char (point-min))
                                   (unless (save-excursion (let ((case-fold-search nil))(search-forward "ERROR: " nil t)))
                                     (insert ',link "\n")
                                     (write-region nil nil mpvarchive t))
                                   (kill-buffer))))))
#+end_src

Here is how I integrate the above function with qutebrowser such that I simply use the keybinding ",n" and hint all the links I want enqueued in mpv, or ",m" for a single link, or ",M" for the link of the webpage itself. Simply add these lines to config.py of qutebrowser:

#+begin_src python
  config.bind(',M', 'spawn emacsclient -n -e "(mpv-enqueue-maybe-archive \\"{url}\\")"')
  config.bind(',m', 'hint links spawn emacsclient -n -e "(mpv-enqueue-maybe-archive \\"{hint-url}\\")"')
  config.bind(',n', 'hint --rapid links spawn emacsclient -n -e "(mpv-enqueue-maybe-archive \\"{hint-url}\\")"')
#+end_src

** =elfeed-mpv=
The following function and keybindings integrate the enqueuer with elfeed so that you can simply hit "m" to play the video from the list view (or hit "n" to skip the listing).
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/youtube.el
  (defun elfeed-mpv ()
    (interactive)
    (mpv-play-url (elfeed-entry-link (elfeed-search-selected :single)))
                                          ; (mpv-enqueue-maybe-archive (elfeed-entry-link (elfeed-search-selected :single)))
    (elfeed-search-untag-all-unread))

                                          ; (define-key elfeed-search-mode-map "m" 'elfeed-mpv)
                                          ; (define-key elfeed-search-mode-map "n" 'elfeed-search-untag-all-unread)
#+end_src

If you are not an elfeed user I suggest that you give it a try as it's the best feed reader I've found. Here are some video feeds to get you started:
#+begin_src elisp
  (setq elfeed-feeds
        '(("https://www.reddit.com/r/lectures/new/.rss") ; new videos from r/lectures
          ("https://www.reddit.com/r/documentaries/top/.rss?sort=top&t=day") ; daily top videos from r/documentaries
          ("https://www.reddit.com/search.rss?q=url%3A%28youtu.be+OR+youtube.com%29&sort=top&t=week&include_over_18=1&type=link") ; weekly top youtube videos
          ("https://www.youtube.com/feeds/videos.xml?channel_id=UCn-HUzO0Xfn1Jx4bRZ7kPew") ; Ben Franklin's World
          ("https://www.youtube.com/feeds/videos.xml?playlist_id=PLp12xt0S4J0UYXerKrIPCLTk15ZUzFdKz") ; Popular on Youtube Canada
          ("https://www.youtube.com/feeds/videos.xml?user=academyofideas") ; Academy of Ideas
          ))
#+end_src

** =mpv-search-archive=
Now, for searching the archive that you would have created by using the above functions:
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/youtube.el
  (defun mpv-search-archive (query)
    (interactive (list (read-from-minibuffer "Search mpv archive: " nil nil nil 'mpv-history)))
    (let ((link)(title)(time)(lines))
      (with-temp-buffer (insert-file-contents mpvarchive)
                        (goto-char (point-min))
                        (while (search-forward query nil t)
                          (re-search-backward "^https?://")
                          (setq link (thing-at-point 'url))
                          (forward-line 1)
                          (setq title (buffer-substring (line-beginning-position)(line-end-position)))
                          (forward-line 1)
                          (setq time (buffer-substring (line-beginning-position)(line-end-position)))
                          (setq lines (cons (cons (concat title " [" time "]") link) lines))))
      (delq nil (delete-dups lines))
      (ivy-read "mpv archive result(s): " (mapcar 'car lines)
                :sort nil
                :re-builder #'regexp-quote
                :action '(1
                          ("o" (lambda (x)
                                 (mpv-enqueue-maybe-archive (cdr (assoc x lines)) t))
                           "play")
                          ("b" (lambda (x)
                                 (browse-url-browser-function (cdr (assoc x lines))))
                           "browse")
                          ("w" (lambda (x)
                                 (kill-new (cdr (assoc x lines))))
                           "copy url")
                          ("d" (lambda (x)
                                 (ivy-youtube-dl (cdr (assoc x lines))))
                           "download")))))
#+end_src

The above function which searches the mpv archive can also directly download the video with youtube-dl using the "ivy-youtube-dl" function which I've included at the end of this post.

** =mpv-build-playlist=
Sometimes, you may want to save the links for later viewing without enqueueing them right then. In that case you can use the following function which will build a plaintext .m3u playlist which you can later feed to mpv with a handy function that comes next after this.
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/youtube.el
  (defun mpv-build-playlist (&optional link)
    (interactive)
    (unless link (setq link (current-kill 0)))
    (write-region (concat link "\n") nil "~/.cache/mpv-built-playlist.m3u" t))
#+end_src

You can integrate it with qutebrowser by putting the following lines in your config.py:
#+begin_src python
  config.bind(',P', 'spawn emacsclient -n -e "(mpv-build-playlist \\"{url}\\")"')
  config.bind(',p', 'hint links spawn emacsclient -n -e "(mpv-build-playlist \\"{hint-url}\\")"')
  config.bind(',l', 'hint --rapid links spawn emacsclient -n -e "(mpv-build-playlist \\"{hint-url}\\")"')
#+end_src

** =save_playlist.lua=
Sometimes you may have enqueued a bunch of videos in mpv, and midway you want to stop watching videos and save them for later viewing. The easiet way to do that is to have the following script saved at the location "~/.config/mpv/scripts/save_playlist.lua". Then you can simply hit "y" to save the currently playing list of videos and quit mpv with "Shift-q" so that when you later replay the playlist it will start from where you had left off. I had found this online somewhere but sorry I can't find its direct link now.
#+begin_src lua :tangle ~/.config/mpv/scripts/save_playlist.lua
  local playlist_savepath = (os.getenv('HOME')..'/.cache')
  local utils = require("mp.utils")
  local msg = require("mp.msg")
  local filename = nil

  function save_playlist()
    local length = mp.get_property_number('playlist-count', 0)
    if length == 0 then return end
    local savepath = utils.join_path(playlist_savepath, os.time().."-size_"..length.."-playlist.m3u")
    local file, err = io.open(savepath, "w")
    if not file then
      msg.error("Error in creating playlist file, check permissions and paths: "..(err or ""))
    else
      local i=0
      while i < length do
        local pwd = mp.get_property("working-directory")
        local filename = mp.get_property('playlist/'..i..'/filename')
        local fullpath = filename
        if not filename:match("^%a%a+:%/%/") then
          fullpath = utils.join_path(pwd, filename)
        end
        file:write(fullpath, "\n")
        i=i+1
      end
      msg.info("Playlist written to: "..savepath)
      mp.osd_message("Playlist written to: "..savepath)
      file:close()
    end
  end

  mp.add_key_binding("y", save_playlist)
#+end_src

** =mpv-enqueue-play-playlist=
Now after you've saved or built your playlists you can later select them for playing with this handy function which will search for all the m3u files in the cache directory. Once you select a file it will be sent to mpv and deleted from your cache folder so that it won't be littered with unneeded files.
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/youtube.el
  (defun mpv-enqueue-play-playlist ()
    (interactive)
    (ivy-read "Files: "
              (directory-files "~/.cache/" t "\\.m3u")
              :action (lambda (x)
                        (mpv-enqueue-archive x t)
                        (sleep-for 2)
                        (delete-file x))
              :require-match t
              :sort nil))
#+end_src

** =mpv-enqueue-play-archive=
But in case you did not save your playlist and you simply want to replay the last n number of videos you had enqueued you can use the following function and send it the number with a prefix argument like "C-u 10" otherwise it will play only one last video. This function creates a temporary playlist files and sends it to mpv and then deletes the file.
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/youtube.el
  (defun mpv-enqueue-play-archive (number)
    (interactive "p")
    (let ((url)(list)(playlist))
      (with-temp-buffer (insert-file-contents mpvarchive)
                        (goto-char (point-max))
                        (dotimes (i number list)
                          (re-search-backward "^https?://" nil t)
                          (setq url (thing-at-point 'url))
                          (setq list (cons url list))))
      (setq list (nreverse list))
      (setq playlist (make-temp-file "archive-playlist" nil ".m3u" (mapconcat 'identity list "\n")))
      (mpv-enqueue-archive playlist t)
      (sleep-for 2)
      (delete-file playlist)))
#+end_src

** =ivy-youtube-dl=
And here's the youtube-dl function which you can integrate with the archive search and your browser (or simply run it when you have a link in your clipboard). At the ivy prompt you can simply hit return to download the video with the "best" format, or you can choose any other format from the list by selecting it and hitting return, otherwise if you want a combination of different formats then you'll need to enter their codes yourself like "136+bestaudio" or something:
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/youtube.el
  (defun ivy-youtube-dl (&optional link)
    (interactive)
    (let ((link (or link (current-kill 0)))
          (buffer (generate-new-buffer "*ytd-formats*")))
      (make-process :name "ytd-formats"
                    :buffer buffer
                    :command (list "youtube-dl" "--list-formats" link)
                    :connection-type 'pipe
                    :sentinel `(lambda (p e)
                                 (set-buffer ',buffer)
                                 (goto-char (point-min))
                                 (unless (search-forward "format code" nil t)
                                   (kill-buffer)
                                   (error "url not supported"))
                                 (forward-line 1)
                                 (let (list)
                                   (while (not (eobp))
                                     (setq list (cons
                                                 (split-string
                                                  (buffer-substring-no-properties
                                                   (point)
                                                   (point-at-eol)) "\n" t nil)
                                                 list))
                                     (forward-line 1))
                                   (setq list (nreverse list))
                                   (kill-buffer "*ytd-formats*")
                                   (ivy-read "youtube-dl formats (vid+aud): " list
                                             :action (lambda (x)
                                                       (youtube-dl
                                                        (substring-no-properties
                                                         (format "%s" x)
                                                         (if (string-match "(" (format "%s" x))
                                                             (match-end 0)
                                                           nil)
                                                         (string-match "[[:space:]]" (format "%s" x))) ',link))
                                             :sort nil
                                             :history 'youtube-dl
                                             :re-builder #'regexp-quote
                                             :preselect "best"))))))
  (defun youtube-dl (fmt link)
    (let ((buffer (generate-new-buffer "*youtube-dl*")))
      (with-current-buffer buffer
        (ansi-color-for-comint-mode-on)
        (comint-mode))
      (make-process :name "youtube-dl"
                    :buffer buffer
                    :command (list
                              "youtube-dl"
                              "--flat-playlist"
                              "--format" fmt link)
                    :connection-type 'pty
                    :filter 'comint-output-filter
                    :sentinel (lambda (p e)
                                (make-process :name "notify"
                                              :connection-type 'pipe
                                              :command (list
                                                        "notify-send"
                                                        (format "%s %s" p e)
                                                        "download complete"))
                                (message
                                 "Process %s %s" p (replace-regexp-in-string "\n\\'" "" e))))))
#+end_src

And you can integrate it with qutebrowser by adding the following lines to your config.py:
#+begin_src python
  config.bind(',y', 'hint links spawn emacsclient -n -e "(ivy-youtube-dl \\"{hint-url}\\")"')
  config.bind(',Y', 'spawn emacsclient -n -e "(ivy-youtube-dl \\"{url}\\")"')
#+end_src

Sorry, no screenshots as it's basically the standard ivy and mpv interface that you will see when using these functions. Give them a try, they work really well for me and are very basic.

* Workspaces
Boy this sure is verbose. I hope future me dries this up.
#+begin_src emacs-lisp :tangle ~/.emacs.d/config/workspaces.el
  (use-package eyebrowse ; because tab-bar-mode doesn't work on mac
    :config
    (eyebrowse-mode t)
    :init
    (rbon-define-key 'global '(normal visual emacs)
      '("SPC `"     ("workspace"))
      '("SPC TAB"   ("last used workspace" . eyebrowse-last-window-config))
      '("SPC ` h"   ("previous workspace" . eyebrowse-prev-window-config))
      '("SPC ` l"   ("next workspace" . eyebrowse-next-window-config))
      '("SPC ` TAB" ("last used workspace" . eyebrowse-last-window-config))
      '("SPC ` c"   ("close workspace" . eyebrowse-close-window-config))
      '("SPC ` r"   ("rename workspace" . eyebrowse-rename-window-config))
      '("SPC ` s"   ("switch to workspace..." . eyebrowse-switch-to-window-config))
      '("SPC ` 0"   ("switch to workspace 0" . eyebrowse-switch-to-window-config-0))
      '("SPC 0"     ("switch to workspace 0" . eyebrowse-switch-to-window-config-0))
      '("SPC ` 1"   ("switch to workspace 1" . eyebrowse-switch-to-window-config-1))
      '("SPC 1"     ("switch to workspace 1" . eyebrowse-switch-to-window-config-1))
      '("SPC ` 2"   ("switch to workspace 2" . eyebrowse-switch-to-window-config-2))
      '("SPC 2"     ("switch to workspace 2" . eyebrowse-switch-to-window-config-2))
      '("SPC ` 3"   ("switch to workspace 3" . eyebrowse-switch-to-window-config-3))
      '("SPC 3"     ("switch to workspace 3" . eyebrowse-switch-to-window-config-3))
      '("SPC ` 4"   ("switch to workspace 4" . eyebrowse-switch-to-window-config-4))
      '("SPC 4"     ("switch to workspace 4" . eyebrowse-switch-to-window-config-4))
      '("SPC ` 5"   ("switch to workspace 5" . eyebrowse-switch-to-window-config-5))
      '("SPC 5"     ("switch to workspace 5" . eyebrowse-switch-to-window-config-5))
      '("SPC ` 6"   ("switch to workspace 6" . eyebrowse-switch-to-window-config-6))
      '("SPC 6"     ("switch to workspace 6" . eyebrowse-switch-to-window-config-6))
      '("SPC ` 7"   ("switch to workspace 7" . eyebrowse-switch-to-window-config-7))
      '("SPC 7"     ("switch to workspace 7" . eyebrowse-switch-to-window-config-7))
      '("SPC ` 8"   ("switch to workspace 8" . eyebrowse-switch-to-window-config-8))
      '("SPC 8"     ("switch to workspace 8" . eyebrowse-switch-to-window-config-8))
      '("SPC ` 9"   ("switch to workspace 9" . eyebrowse-switch-to-window-config-9))
      '("SPC 9"     ("switch to workspace 9" . eyebrowse-switch-to-window-config-9))
      '("SPC ` n"   ("new workspace" . eyebrowse-create-window-config))))
#+end_src

